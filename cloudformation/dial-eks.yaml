AWSTemplateFormatVersion: '2010-09-09'
Description: 'DIAL EKS Cluster with OIDC provider'

Parameters:
  ClusterName:
    Type: String
  
  KubernetesVersion:
    Type: String
    Default: '1.31'
  
  VPCId:
    Type: String
  
  PrivateSubnet1Id:
    Type: String
  
  PrivateSubnet2Id:
    Type: String
  
  EKSSecurityGroupId:
    Type: String
  
  NodeInstanceType:
    Type: String
    Default: 'm5.large'
    Description: EC2 instance type for EKS nodes
  
  NodeMinSize:
    Type: Number
    Default: 2
    Description: Minimum number of nodes
  
  NodeMaxSize:
    Type: Number
    Default: 10
    Description: Maximum number of nodes
  
  NodeDesiredSize:
    Type: Number
    Default: 3
    Description: Desired number of nodes

Resources:
  # EKS Cluster IAM Role
  EKSClusterRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ClusterName}-cluster-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: eks.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonEKSClusterPolicy'
        - 'arn:aws:iam::aws:policy/AmazonEKSVPCResourceController'
      Tags:
        - Key: Name
          Value: !Sub '${ClusterName}-cluster-role'

  # EKS Node IAM Role
  EKSNodeRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ClusterName}-node-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy'
        - 'arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy'
        - 'arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly'
        - 'arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore'
      Tags:
        - Key: Name
          Value: !Sub '${ClusterName}-node-role'

  # Wait for VPC Endpoints to be ready
  WaitForEndpointsLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DescribeVPCEndpoints
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeVpcEndpoints
                Resource: '*'

  WaitForEndpointsFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt WaitForEndpointsLambdaRole.Arn
      Runtime: python3.11
      Timeout: 300
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import time
          
          def handler(event, context):
              try:
                  if event['RequestType'] == 'Delete':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return
                  
                  ec2 = boto3.client('ec2')
                  vpc_id = event['ResourceProperties']['VpcId']
                  required_services = [
                      'com.amazonaws.{}.ec2'.format(event['ResourceProperties']['Region']),
                      'com.amazonaws.{}.ecr.api'.format(event['ResourceProperties']['Region']),
                      'com.amazonaws.{}.ecr.dkr'.format(event['ResourceProperties']['Region']),
                      'com.amazonaws.{}.s3'.format(event['ResourceProperties']['Region']),
                      'com.amazonaws.{}.sts'.format(event['ResourceProperties']['Region']),
                      'com.amazonaws.{}.eks'.format(event['ResourceProperties']['Region'])
                  ]
                  
                  # Wait up to 5 minutes for endpoints to be available
                  max_attempts = 30
                  for attempt in range(max_attempts):
                      response = ec2.describe_vpc_endpoints(
                          Filters=[{'Name': 'vpc-id', 'Values': [vpc_id]}]
                      )
                      
                      available_services = set()
                      for endpoint in response['VpcEndpoints']:
                          if endpoint['State'] == 'available':
                              available_services.add(endpoint['ServiceName'])
                      
                      # Check if all required services are available
                      missing = [s for s in required_services if s not in available_services]
                      
                      if not missing:
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, 
                                          {'Message': 'All VPC Endpoints are available'})
                          return
                      
                      if attempt < max_attempts - 1:
                          time.sleep(10)  # Wait 10 seconds before retry
                  
                  # If we get here, not all endpoints are ready
                  cfnresponse.send(event, context, cfnresponse.FAILED,
                                  {'Message': 'VPC Endpoints not ready after 5 minutes'})
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED,
                                  {'Message': str(e)})

  WaitForEndpoints:
    Type: Custom::WaitForEndpoints
    Properties:
      ServiceToken: !GetAtt WaitForEndpointsFunction.Arn
      VpcId: !Ref VPCId
      Region: !Ref AWS::Region

  # EKS Cluster
  EKSCluster:
    Type: AWS::EKS::Cluster
    DependsOn: WaitForEndpoints
    Properties:
      Name: !Ref ClusterName
      Version: !Ref KubernetesVersion
      RoleArn: !GetAtt EKSClusterRole.Arn
      ResourcesVpcConfig:
        SecurityGroupIds:
          - !Ref EKSSecurityGroupId
        SubnetIds:
          - !Ref PrivateSubnet1Id
          - !Ref PrivateSubnet2Id
        EndpointPrivateAccess: true
        EndpointPublicAccess: false
      Logging:
        ClusterLogging:
          EnabledTypes:
            - Type: api
            - Type: audit
            - Type: authenticator
            - Type: controllerManager
            - Type: scheduler
      Tags:
        - Key: Name
          Value: !Ref ClusterName

  # EKS Node Group
  EKSNodeGroup:
    Type: AWS::EKS::Nodegroup
    DependsOn: EKSCluster
    Properties:
      ClusterName: !Ref ClusterName
      NodegroupName: !Sub '${ClusterName}-ng-1'
      NodeRole: !GetAtt EKSNodeRole.Arn
      Subnets:
        - !Ref PrivateSubnet1Id
        - !Ref PrivateSubnet2Id
      ScalingConfig:
        MinSize: !Ref NodeMinSize
        MaxSize: !Ref NodeMaxSize
        DesiredSize: !Ref NodeDesiredSize
      InstanceTypes:
        - !Ref NodeInstanceType
        - t3.large
        - t3a.large
        - m5a.large
      AmiType: AL2_x86_64
      DiskSize: 100
      Tags:
        Name: !Sub '${ClusterName}-ng-1'

  # OIDC Provider
  OIDCProvider:
    Type: AWS::IAM::OIDCProvider
    Properties:
      Url: !GetAtt EKSCluster.OpenIdConnectIssuerUrl
      ClientIdList:
        - sts.amazonaws.com
      ThumbprintList:
        # EKS OIDC thumbprint - valid for all regions
        - '9e99a48a9960b14926bb7f3b02e22da2b0ab7280'
      Tags:
        - Key: Name
          Value: !Sub '${ClusterName}-oidc-provider'

  # EKS Addon - VPC CNI
  VPCCNIAddon:
    Type: AWS::EKS::Addon
    DependsOn: EKSNodeGroup
    Properties:
      ClusterName: !Ref ClusterName
      AddonName: vpc-cni
      ResolveConflicts: OVERWRITE

  # EKS Addon - CoreDNS
  CoreDNSAddon:
    Type: AWS::EKS::Addon
    DependsOn: EKSNodeGroup
    Properties:
      ClusterName: !Ref ClusterName
      AddonName: coredns
      ResolveConflicts: OVERWRITE

  # EKS Addon - kube-proxy
  KubeProxyAddon:
    Type: AWS::EKS::Addon
    DependsOn: EKSNodeGroup
    Properties:
      ClusterName: !Ref ClusterName
      AddonName: kube-proxy
      ResolveConflicts: OVERWRITE

Outputs:
  ClusterName:
    Description: EKS Cluster Name
    Value: !Ref ClusterName
    Export:
      Name: !Sub '${AWS::StackName}-ClusterName'

  ClusterArn:
    Description: EKS Cluster ARN
    Value: !GetAtt EKSCluster.Arn

  ClusterEndpoint:
    Description: EKS Cluster Endpoint
    Value: !GetAtt EKSCluster.Endpoint

  OIDCProviderArn:
    Description: OIDC Provider ARN
    Value: !GetAtt OIDCProvider.Arn
    Export:
      Name: !Sub '${AWS::StackName}-OIDCProviderArn'

  OIDCProviderUrl:
    Description: OIDC Provider URL
    Value: !GetAtt EKSCluster.OpenIdConnectIssuerUrl
    Export:
      Name: !Sub '${AWS::StackName}-OIDCProviderUrl'

  ClusterSecurityGroupId:
    Description: EKS Cluster Security Group ID
    Value: !GetAtt EKSCluster.ClusterSecurityGroupId

  NodeRoleArn:
    Description: Node IAM Role ARN
    Value: !GetAtt EKSNodeRole.Arn
